=== Baseline ===
solveGrid: 24731.000ms
Object {contradictionSearches: 1164771, contradictionSearchesPassed: 582386, solveGridRecursiveCalls: 1164771}

=== After moving grid null value into variable ===
solveGrid: 26374.000ms main.js:91
Object {contradictionSearches: 1164771, contradictionSearchesPassed: 582386, solveGridRecursiveCalls: 1164771}

=== Set cloned array contents with for loop instead of allocating a new array and then calling oldArray.slice(0) ===
Rejecting this, because it's slower.

solveGrid: 27785.000ms main.js:91
Object {contradictionSearches: 1164771, contradictionSearchesPassed: 582386, solveGridRecursiveCalls: 1164771}

=== Grid.emptyCell is an integer (255) instead of null ===
solveGrid: 18649.000ms main.js:91
Object {contradictionSearches: 1164771, contradictionSearchesPassed: 582386, solveGridRecursiveCalls: 1164771} 

=== Grid stores data in Uint8Array ===
Rejecting this as same performance as above.

solveGrid: 18700.000ms main.js:91
Object {contradictionSearches: 1164771, contradictionSearchesPassed: 582386, solveGridRecursiveCalls: 1164771}

=== Remove temp variable in new Grid() ===
This surprised me.

solveGrid: 17705.000ms main.js:91
Object {contradictionSearches: 1164771, contradictionSearchesPassed: 582386, solveGridRecursiveCalls: 1164771}

=== Comment out lines that increment perfStats counters ===
Seems like this doesn't make too much of a difference.

solveGrid: 17493.000ms main.js:91
Object {contradictionSearches: 0, contradictionSearchesPassed: 0, solveGridRecursiveCalls: 0} 

=== Use local variables instead of arrays to store per-row and per-column counts for 0s and 1s ===
solveGrid: 14070.000ms main.js:92
Object {contradictionSearches: 1164771, contradictionSearchesPassed: 582386, solveGridRecursiveCalls: 1164771} 

=== Don't clone grids on the recursive step, use "dancing links" style backtracking instead ===
solveGrid: 10338.000ms main.js:92
Object {contradictionSearches: 1164771, contradictionSearchesPassed: 582386, solveGridRecursiveCalls: 1164771} 